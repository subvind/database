# NESTCODER

You are NestCoder, a HTMX, EJS and TypeScript/NestJS language coding assistant.

## INPUT: 

You will receive a TARGET <FILE/> in the EJS or TypeScript/NestJS language, some additional <FILE/>'s for context, and a change or refactor <REQUEST/>, from the user.

## OUTPUT:

You must answer with one or more <FILE/> tags, including files to be overwritten, in order to fulfill the user's request.

---

# EXAMPLE NESTCODER USAGE

## Suppose you're given the following INPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/_.ts">
// A polymorphic List with two constructors:
// - Cons: appends an element to a list
// - Nil: the empty list
export type List<A>
  = { "$": "Cons", head: A, tail: List<A> }
  | { "$": "Nil" };
</FILE>

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts" TARGET>
// The map function for List, to be implemented
import { List } from "./_";

export function map<A, B>(fn: (a: A) => B, list: List<A>): List<B> {
  ?
}
</FILE>

<REQUEST>
complete the map function
</REQUEST>

## Then, you must answer with the following OUTPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts">
import { List } from "./_";

// Applies a function to each element of a list.
// - fn: the function to be applied
// - xs: the elements to apply fn to
// = a new list with fn applied to all elements
export function map<A, B>(xs: List<A>, fn: (a: A) => B): List<B> {
  switch (xs.$) {
    case "Cons": {
      var head = fn(xs.head);
      var tail = map(xs.tail, fn);
      return { $: "Cons", head, tail };
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
</FILE>

(Because it fulfills the user's request perfectly.)

---

# GUIDE FOR THE TYPESCRIPT LANGUAGE

- Your code must be inspired by pure functional programming languages like Haskell.

- Every file must declare only, and only one, top-level function or datatype.

- Functions must be pure, using switch instead of 'if-else' or 'case-of'.

- When defining local variables, align equal signs whenever possible.

- Use CamelCase for everything. (IMPORTANT)

- A 'Foo/Bar' top-level definition must be either on './Foo/Bar.ts' or './Foo/Bar/_.ts'. 

# GUIDE FOR THE EJS LANGUAGE

- Use HTMX for frontend.

## Top-Level Function

Every .ts file must define ONE top-level function. Example:

```typescript
// Calculates the size of an HTerm
// - term: the HTerm to measure
// = the number of nodes in the term
export function size(term: HTerm): number {
  switch (term.$) {
    case "Lam": {
      var bod_size = size(term.bod({$: "Var", nam: term.nam}));
      return 1 + bod_size;
    }
    case "App": {
      var fun_size = size(term.fun);
      var arg_size = size(term.arg);
      return 1 + fun_size + arg_size;
    }
    case "Var": {
      return 1;
    }
  }
}
```

Where:
- The function name is defined (e.g., 'size')
- Parameters are specified with their types (e.g., 'term: HTerm')
- The return type is specified (e.g., ': number')
- The function body uses a switch statement for pattern matching
- Local variables are used to make the code less horizontal

## Top-Level Datatype

Alternatively, a .ts file can also define a datatype (ADT). Example:

```typescript
// Represents a Higher-Order Abstract Syntax Term
// - Lam: lambda abstraction
// - App: function application
// - Var: variable
export type HTerm
  = { $: "Lam", bod: (x: HTerm) => HTerm }
  | { $: "App", fun: HTerm, arg: HTerm }
  | { $: "Var", nam: string }
```

ADTs must follow this convention:
- Constructors represented as objects
- The dollar-sign is used for the constructor name
- Other object fields are the constructor fields

## Idiomatic TypeScript Examples

Below are some additional idiomatic TypeScript in the purely functional style: 

### List/zip.ts

```typescript
import { List } from "./_";

// Combines two lists into a list of pairs
// - xs: the first input list
// - ys: the second input list
// = a new list of pairs, with length equal to the shorter input list
export function zip<A, B>(xs: List<A>, ys: List<B>): List<[A, B]> {
  switch (xs.$) {
    case "Cons": {
      switch (ys.$) {
        case "Cons": {
          var head = [xs.head, ys.head] as [A,B];
          var tail = zip(xs.tail, ys.tail);
          return { $: "Cons", head, tail };
        }
        case "Nil": {
          return { $: "Nil" };
        }
      }
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### List/filter.ts

```typescript
import { List } from "./_";

// Filters a list based on a predicate function
// - xs: the input list
// - pred: the predicate function to test each element
// = a new list containing only elements that satisfy the predicate
export function filter<A>(xs: List<A>, pred: (a: A) => boolean): List<A> {
  switch (xs.$) {
    case "Cons": {
      var head = xs.head;
      var tail = filter(xs.tail, pred);
      return pred(xs.head) ? { $: "Cons", head, tail } : tail;
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### Tree/_.ts

```typescript
// Represents a binary tree
// - Node: an internal node with a value and two subtrees
// - Leaf: a leaf node (empty)
export type Tree<A>
  = { $: "Node", val: A, left: Tree<A>, right: Tree<A> }
  | { $: "Leaf" };
```

### Tree/sum.ts

```typescript
import { Tree } from "./_";

// Sums all values in a numeric tree
// - tree: the tree to sum
// = the sum of all values in the tree
export function sum(tree: Tree<number>): number {
  switch (tree.$) {
    case "Node": {
      var left  = sum(tree.left);
      var right = sum(tree.right);
      return tree.val + left + right;
    }
    case "Leaf": {
      return 0;
    }
  }
}
```

### V3/_.ts

```typescript
// Represents a 3D vector
export type V3
  = { $: "V3", x: number, y: number, z: number };
```

### V3/dot.ts

```typescript
import { V3 } from "./_";

// Calculates the dot product of two 3D vectors
// - a: the first vector
// - b: the second vector
// = the dot product of a and b
export function dot(a: V3, b: V3): number {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}
```

---

# NOTES

- Make ONLY the changes necessary to correctly fulfill the user's REQUEST.

- Do NOT fix, remove, complete or alter any parts unrelated to the REQUEST.

- Pay attention to the user's style, and mimic it as close as possible.

- Pay attention to the TypeScript examples and mimic their style as a default.

- Consult TypeScript guide to emit idiomatic correct code.

- Do NOT use or assume the existence of files that weren't shown to you.

- Be precise and careful in your modifications.

---

# TASK

You will now be given the actual INPUT you must work with.

<FILE path="/home/travis/Projects/database/src/app.module.ts">
import { Module } from '@nestjs/common';
import { AuthModule } from './auth/auth.module';
import { StorageModule } from './storage/storage.module';
import { ScheduleModule } from '@nestjs/schedule';

@Module({
  imports: [
    StorageModule,
    AuthModule,
    ScheduleModule.forRoot(),
  ],
})
export class AppModule {}
</FILE>
<FILE path="/home/travis/Projects/database/src/storage/storage.module.ts">
import { Module } from '@nestjs/common';
import { StorageService } from './storage.service';
import { StorageController } from './storage.controller';
import { JwtModule } from '@nestjs/jwt';
import { ScheduleModule } from '@nestjs/schedule';

@Module({
  imports: [
    JwtModule.register({
      secret: 'your_jwt_secret', // TODO: In production, use an environment variable
      signOptions: { expiresIn: '60m' },
    }),
    ScheduleModule.forRoot(),
  ],
  providers: [StorageService],
  controllers: [StorageController],
  exports: [StorageService],
})
export class StorageModule {}
</FILE>
<FILE path="/home/travis/Projects/database/src/storage/storage.service.ts">
import { Injectable, OnModuleInit, OnModuleDestroy, UnauthorizedException, ForbiddenException } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import * as fs from 'fs/promises';
import * as bcrypt from 'bcrypt';
import { JwtService } from '@nestjs/jwt';

interface User {
  username: string;
  passwordHash: string;
  databases: number[];
  isAdmin: boolean;
}

@Injectable()
export class StorageService implements OnModuleInit, OnModuleDestroy {
  private databases: Map<number, Map<string, any>> = new Map();
  private users: Map<string, User> = new Map();
  private walFile: string = 'data/wal.log';
  private snapshotFile: string = 'data/snapshot.json';
  private usersFile: string = 'data/users.json';
  private walStream: fs.FileHandle | null = null;

  constructor(private jwtService: JwtService) {}

  async onModuleInit() {
    await this.loadSnapshot();
    await this.loadUsers();
    await this.replayWAL();
    this.walStream = await fs.open(this.walFile, 'a');
  }

  async onModuleDestroy() {
    await this.createSnapshot();
    await this.saveUsers();
    await this.walStream?.close();
  }

  private async loadSnapshot() {
    try {
      const data = await fs.readFile(this.snapshotFile, 'utf-8');
      const parsedData = JSON.parse(data);
      this.databases = new Map(Object.entries(parsedData).map(([key, value]) => [Number(key), new Map(Object.entries(value))]));
    } catch (error) {
      console.log('No snapshot found or error loading snapshot');
    }
  }

  private async loadUsers() {
    try {
      const data = await fs.readFile(this.usersFile, 'utf-8');
      const parsedData = JSON.parse(data);
      this.users = new Map(Object.entries(parsedData));
    } catch (error) {
      console.log('No users file found or error loading users');
    }
  }

  private async replayWAL() {
    try {
      const data = await fs.readFile(this.walFile, 'utf-8');
      const lines = data.split('\n').filter(line => line.trim() !== '');
      for (const line of lines) {
        const [operation, ...args] = JSON.parse(line);
        switch (operation) {
          case 'set':
            this.set(args[0], Number(args[1]), args[2], args[3]);
            break;
          case 'incr':
            this.incr(args[0], Number(args[1]), args[2]);
            break;
          case 'sadd':
            this.sadd(args[0], Number(args[1]), args[2], ...args.slice(3));
            break;
          case 'del':
            this.del(args[0], Number(args[1]), ...args.slice(2));
            break;
          case 'expire':
            this.expire(args[0], Number(args[1]), args[2], Number(args[3]));
            break;
          case 'rpush':
            this.rpush(args[0], Number(args[1]), args[2], ...args.slice(3));
            break;
          case 'lpop':
            this.lpop(args[0], Number(args[1]), args[2]);
            break;
        }
      }
    } catch (error) {
      console.log('No WAL found or error replaying WAL');
    }
  }

  private async appendToWAL(operation: string, ...args: any[]) {
    const logEntry = JSON.stringify([operation, ...args]) + '\n';
    await this.walStream?.write(logEntry);
  }

  private async createSnapshot() {
    const snapshotData = JSON.stringify(Object.fromEntries(Array.from(this.databases.entries()).map(([key, value]) => [key, Object.fromEntries(value)])));
    await fs.writeFile(this.snapshotFile, snapshotData);
    await fs.truncate(this.walFile, 0);
  }

  private async saveUsers() {
    const userData = JSON.stringify(Object.fromEntries(this.users));
    await fs.writeFile(this.usersFile, userData);
  }

  async createUser(username: string, password: string): Promise<void> {
    if (this.users.has(username)) {
      throw new Error('User already exists');
    }
    const saltRounds = 10;
    const passwordHash = await bcrypt.hash(password, saltRounds);
    let isAdmin: boolean = false;
    if (process.env.ADMIN) {
      if (process.env.ADMIN === username) {
        isAdmin = true;
      }
    } else {
      if (username === 'root') {
        isAdmin = true
      }
    }
    const newUser: User = {
      username,
      passwordHash,
      databases: [],
      isAdmin
    };
    this.users.set(username, newUser);
    await this.saveUsers();
  }

  async validateUser(username: string, password: string): Promise<any> {
    const user = this.users.get(username);
    if (user && await bcrypt.compare(password, user.passwordHash)) {
      const { passwordHash, ...result } = user;
      return result;
    }
    return null;
  }

  async login(user: any) {
    const payload = { username: user.username, sub: user.userId };
    return {
      access_token: this.jwtService.sign(payload),
    };
  }

  async assignUserToDatabase(username: string, dbIndex: number): Promise<void> {
    const user = this.users.get(username);
    if (!user) throw new UnauthorizedException('User not found');
    
    // Check if the database is already assigned to another user
    for (const [otherUsername, otherUser] of this.users.entries()) {
      if (otherUsername !== username && otherUser.databases.includes(dbIndex)) {
        throw new ForbiddenException('Database already assigned to another user');
      }
    }
    
    if (!user.databases.includes(dbIndex)) {
      user.databases.push(dbIndex);
      await this.saveUsers();
    }
  }

  private getDatabase(dbIndex: number): Map<string, string[]> {
    if (!this.databases.has(dbIndex)) {
      this.databases.set(dbIndex, new Map());
    }
    return this.databases.get(dbIndex)!;
  }

  private checkUserAccess(username: string, dbIndex: number): boolean {
    const user = this.users.get(username);
    return user ? user.databases.includes(dbIndex) : false;
  }

  async rpush(username: string, dbIndex: number, key: string, ...values: string[]): Promise<number> {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    if (!db.has(key)) {
      db.set(key, []);
    }
    const list = db.get(key)!;
    list.push(...values);
    await this.appendToWAL('rpush', username, dbIndex, key, ...values);
    return list.length;
  }

  lrange(username: string, dbIndex: number, key: string, start: number, stop: number): string[] {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    const list = db.get(key) || [];
    if (start < 0) start = Math.max(list.length + start, 0);
    if (stop < 0) stop = Math.max(list.length + stop, 0);
    stop = Math.min(stop, list.length - 1);
    return list.slice(start, stop + 1);
  }

  async lpop(username: string, dbIndex: number, key: string): Promise<string | null> {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    const list = db.get(key);
    if (!list || list.length === 0) {
      return null;
    }
    const item = list.shift()!;
    await this.appendToWAL('lpop', username, dbIndex, key);
    return item;
  }

  llen(username: string, dbIndex: number, key: string): number {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    return db.get(key)?.length || 0;
  }

  // String Operations
  async set(username: string, dbIndex: number, key: string, value: string): Promise<'OK'> {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    db.set(key, [value]); // Store value as an array
    await this.appendToWAL('set', username, dbIndex, key, value);
    return 'OK';
  }

  get(username: string, dbIndex: number, key: string): string | null {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    const value = db.get(key);
    return Array.isArray(value) ? value[0] : null;
  }

  async incr(username: string, dbIndex: number, key: string): Promise<number> {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    let value = db.get(key);
    if (!value) {
      value = ['0'];
    } else if (!Array.isArray(value) || typeof Number(value[0]) !== 'number') {
      throw new Error('Value is not a number');
    }
    let number = Number(value[0]) + 1;
    value[0] = `${number}`;
    db.set(key, value);
    await this.appendToWAL('incr', username, dbIndex, key);
    return number;
  }

  async sadd(username: string, dbIndex: number, key: string, ...members: string[]): Promise<number> {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    let set = db.get(key);
    if (!set || !Array.isArray(set)) {
      set = [];
      db.set(key, set);
    }
    const initialSize = set.length;
    members.forEach(member => {
      if (!set.includes(member)) {
        set.push(member);
      }
    });
    const addedCount = set.length - initialSize;
    await this.appendToWAL('sadd', username, dbIndex, key, ...members);
    return addedCount;
  }

  smembers(username: string, dbIndex: number, key: string): string[] {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    const set = db.get(key);
    return set instanceof Set ? Array.from(set) : [];
  }

  sismember(username: string, dbIndex: number, key: string, member: string): boolean {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    const set = db.get(key);
    return set instanceof Set ? set.has(member) : false;
  }

  // Key Management
  async del(username: string, dbIndex: number, ...keys: string[]): Promise<number> {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    let count = 0;
    for (const key of keys) {
      if (db.delete(key)) {
        count++;
      }
    }
    await this.appendToWAL('del', username, dbIndex, ...keys);
    return count;
  }

  exists(username: string, dbIndex: number, ...keys: string[]): number {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    return keys.filter(key => db.has(key)).length;
  }

  async expire(username: string, dbIndex: number, key: string, seconds: number): Promise<boolean> {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    if (!db.has(key)) {
      return false;
    }
    setTimeout(() => {
      db.delete(key);
    }, seconds * 1000);
    await this.appendToWAL('expire', username, dbIndex, key, seconds);
    return true;
  }

  async triggerSnapshot(): Promise<void> {
    await this.createSnapshot();
    await this.saveUsers();
  }

  @Cron(CronExpression.EVERY_30_SECONDS)
  async generateSnapshot() {
    console.log('Generating snapshot...');
    await this.createSnapshot();
    await this.saveUsers();
    console.log('Snapshot generated successfully.');
  }

  async deleteDatabase(username: string, dbIndex: number): Promise<void> {
    const user = this.users.get(username);
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }

    this.databases.delete(dbIndex);
    user.databases = user.databases.filter(db => db !== dbIndex);
    
    // Remove this database from all users
    for (const otherUser of this.users.values()) {
      otherUser.databases = otherUser.databases.filter(db => db !== dbIndex);
    }
    
    await this.saveUsers();
    await this.appendToWAL('deleteDatabase', username, dbIndex);
  }

  async getDatabaseInfo(username: string, dbIndex: number): Promise<any> {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    return {
      keyCount: db.size,
      sizeInBytes: JSON.stringify(Array.from(db)).length,
    };
  }

  async getUserInfo(username: string): Promise<any> {
    const user = this.users.get(username);
    if (!user) throw new UnauthorizedException('User not found');
    const { passwordHash, ...userInfo } = user;
    return userInfo;
  }

  async listDatabases(username: string): Promise<number[]> {
    const user = this.users.get(username);
    if (!user) throw new UnauthorizedException('User not found');
    return user.databases;
  }

  async listUsers(username: string): Promise<string[]> {
    const user = this.users.get(username);
    if (!user || !user.isAdmin) throw new UnauthorizedException('Unauthorized');
    return Array.from(this.users.keys());
  }
}
</FILE>
<FILE path="/home/travis/Projects/database/src/storage/storage.controller.ts">
import { Controller, Post, Get, Body, Param, Query, UseGuards, Request, Delete } from '@nestjs/common';
import { StorageService } from './storage.service';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';
import { LocalAuthGuard } from '../auth/local-auth.guard';

@Controller('storage')
export class StorageController {
  constructor(private readonly storageService: StorageService) {}

  @Post('user')
  async createUser(@Body('username') username: string, @Body('password') password: string): Promise<string> {
    await this.storageService.createUser(username, password);
    return 'User created successfully';
  }

  @UseGuards(LocalAuthGuard)
  @Post('login')
  async login(@Request() req) {
    return this.storageService.login(req.user);
  }

  @UseGuards(JwtAuthGuard)
  @Post('assign-db')
  async assignUserToDatabase(@Request() req, @Body('dbIndex') dbIndex: number): Promise<string> {
    await this.storageService.assignUserToDatabase(req.user.username, dbIndex);
    return 'User assigned to database successfully';
  }

  @UseGuards(JwtAuthGuard)
  @Post('rpush/:dbIndex/:key')
  async rpush(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string,
    @Body('values') values: string[]
  ): Promise<number> {
    return await this.storageService.rpush(req.user.username, Number(dbIndex), key, ...values);
  }

  @UseGuards(JwtAuthGuard)
  @Get('lrange/:dbIndex/:key')
  lrange(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string,
    @Query('start') start: number,
    @Query('stop') stop: number,
  ): string[] {
    return this.storageService.lrange(req.user.username, Number(dbIndex), key, Number(start), Number(stop));
  }

  @UseGuards(JwtAuthGuard)
  @Post('lpop/:dbIndex/:key')
  async lpop(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string
  ): Promise<string | null> {
    return await this.storageService.lpop(req.user.username, Number(dbIndex), key);
  }

  @UseGuards(JwtAuthGuard)
  @Get('llen/:dbIndex/:key')
  llen(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string
  ): number {
    return this.storageService.llen(req.user.username, Number(dbIndex), key);
  }

  @UseGuards(JwtAuthGuard)
  @Post('snapshot')
  async createSnapshot(): Promise<string> {
    await this.storageService.triggerSnapshot();
    return 'Snapshot created successfully';
  }

  @UseGuards(JwtAuthGuard)
  @Post('set/:dbIndex/:key')
  async set(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string,
    @Body('value') value: string
  ): Promise<string> {
    return await this.storageService.set(req.user.username, Number(dbIndex), key, value);
  }

  @UseGuards(JwtAuthGuard)
  @Get('get/:dbIndex/:key')
  get(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string
  ): string | null {
    return this.storageService.get(req.user.username, Number(dbIndex), key);
  }

  @UseGuards(JwtAuthGuard)
  @Post('incr/:dbIndex/:key')
  async incr(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string
  ): Promise<number> {
    return await this.storageService.incr(req.user.username, Number(dbIndex), key);
  }

  @UseGuards(JwtAuthGuard)
  @Post('sadd/:dbIndex/:key')
  async sadd(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string,
    @Body('members') members: string[]
  ): Promise<number> {
    return await this.storageService.sadd(req.user.username, Number(dbIndex), key, ...members);
  }

  @UseGuards(JwtAuthGuard)
  @Get('smembers/:dbIndex/:key')
  smembers(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string
  ): string[] {
    return this.storageService.smembers(req.user.username, Number(dbIndex), key);
  }

  @UseGuards(JwtAuthGuard)
  @Get('sismember/:dbIndex/:key/:member')
  sismember(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string,
    @Param('member') member: string
  ): boolean {
    return this.storageService.sismember(req.user.username, Number(dbIndex), key, member);
  }

  @UseGuards(JwtAuthGuard)
  @Post('del/:dbIndex')
  async del(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Body('keys') keys: string[]
  ): Promise<number> {
    return await this.storageService.del(req.user.username, Number(dbIndex), ...keys);
  }

  @UseGuards(JwtAuthGuard)
  @Get('exists/:dbIndex')
  exists(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Query('keys') keys: string[]
  ): number {
    return this.storageService.exists(req.user.username, Number(dbIndex), ...keys);
  }

  @UseGuards(JwtAuthGuard)
  @Post('expire/:dbIndex/:key')
  async expire(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string,
    @Body('seconds') seconds: number
  ): Promise<boolean> {
    return await this.storageService.expire(req.user.username, Number(dbIndex), key, seconds);
  }

  @UseGuards(JwtAuthGuard)
  @Delete('database/:dbIndex')
  async deleteDatabase(
    @Request() req,
    @Param('dbIndex') dbIndex: number
  ): Promise<string> {
    await this.storageService.deleteDatabase(req.user.username, Number(dbIndex));
    return 'Database deleted successfully';
  }

  @UseGuards(JwtAuthGuard)
  @Get('database/:dbIndex/info')
  async getDatabaseInfo(
    @Request() req,
    @Param('dbIndex') dbIndex: number
  ): Promise<any> {
    return await this.storageService.getDatabaseInfo(req.user.username, Number(dbIndex));
  }

  @UseGuards(JwtAuthGuard)
  @Get('user/info')
  async getUserInfo(@Request() req): Promise<any> {
    return await this.storageService.getUserInfo(req.user.username);
  }

  @UseGuards(JwtAuthGuard)
  @Get('databases')
  async listDatabases(@Request() req): Promise<number[]> {
    return await this.storageService.listDatabases(req.user.username);
  }

  @UseGuards(JwtAuthGuard)
  @Get('users')
  async listUsers(@Request() req): Promise<string[]> {
    return await this.storageService.listUsers(req.user.username);
  }
}
</FILE>
<FILE path="/home/travis/Projects/database/src/auth/auth.module.ts">
import { Module } from '@nestjs/common';
import { PassportModule } from '@nestjs/passport';
import { JwtStrategy } from './jwt.strategy';
import { LocalStrategy } from './local.strategy';
import { StorageModule } from '../storage/storage.module';

@Module({
  imports: [
    PassportModule,
    StorageModule,
  ],
  providers: [JwtStrategy, LocalStrategy],
})
export class AuthModule {}
</FILE>
<FILE path="/home/travis/Projects/database/src/auth/jwt-auth.guard.ts">
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}

</FILE>
<FILE path="/home/travis/Projects/database/src/auth/local-auth.guard.ts">
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard('local') {}
</FILE>
<FILE path="/home/travis/Projects/database/src/logger/custom-logger.ts">
import { ConsoleLogger, Injectable, Inject } from '@nestjs/common';
import * as fs from 'fs';
import * as path from 'path';

@Injectable()
export class CustomLogger extends ConsoleLogger {
  constructor(
    private logId: string,
  ) {
    super(logId);
    this.setLogLevels(['log', 'error', 'warn', 'debug', 'verbose']);
  }

  log(message: string, context?: string) {
    this.printMessage(message, 'log', context);
    // this.emitLogEvent('log', message);
  }

  warn(message: string, context?: string) {
    this.printMessage(message, 'warn', context);
    // this.emitLogEvent('warn', message);
  }

  error(message: string, trace?: string, context?: string) {
    this.printMessage(message, 'error', context);
    // this.emitLogEvent('error', message);
    if (trace) {
      this.printMessage(trace, 'error', context);
    }
  }

  debug(message: string, context?: string) {
    this.printMessage(message, 'debug', context);
  }

  verbose(message: string, context?: string) {
    this.printMessage(message, 'verbose', context);
  }

  private printMessage(message: string, logLevel: string, context?: string) {
    const output = context ? `[${context}] ${message}` : message;
    console.log(`[${this.getNow()}] [${logLevel.toUpperCase()}] [${this.logId}] ${output}`);
  }

  private getNow(): string {
    return new Date().toISOString();
  }

  static write_to_file(message: string) {
    const logFile = path.join(process.cwd(), 'start:dev.stdout.txt');
    fs.appendFile(logFile, message, (err) => {
      if (err) {
        console.error('Failed to write to log file:', err);
      }
    });
  }

  static clearSTDOUT() {
    const logFile = path.join(process.cwd(), 'start:dev.stdout.txt');
    try {
      fs.writeFileSync(logFile, '');
      console.log(`Log file cleared at ${logFile}`);
    } catch (error) {
      console.error('Failed to clear log file:', error);
    }
  }
}
</FILE>
<FILE path="/home/travis/Projects/database/test/check-db-permission-create.test.ts">
import axios from 'axios';

const BASE_URL = 'http://localhost:6969';
const user1 = { username: 'testuser1_perm', password: 'testpassword1' };
const user2 = { username: 'testuser2_perm', password: 'testpassword2' };
let token1: string;
let token2: string;

async function createUserAndLogin(username: string, password: string): Promise<string> {
  console.log(`Creating user or logging in for ${username}...`);
  try {
    await axios.post(`${BASE_URL}/storage/user`, { username, password });
    console.log(`User ${username} created successfully.`);
  } catch (error) {
    console.log(`User ${username} already exists, proceeding to login.`);
  }

  const loginResponse = await axios.post(`${BASE_URL}/storage/login`, { username, password });
  return loginResponse.data.access_token;
}

async function assignUserToDatabase(token: string, dbIndex: number): Promise<boolean> {
  try {
    await axios.post(`${BASE_URL}/storage/assign-db`, { dbIndex }, {
      headers: { Authorization: `Bearer ${token}` }
    });
    console.log(`User assigned to database ${dbIndex} successfully.`);
    return true;
  } catch (error) {
    console.log(`Failed to assign user to database ${dbIndex}: ${error.response?.data}`);
    return false;
  }
}

async function testDatabasePermissions() {
  console.log('Testing database permissions...');

  // Test assigning to a new database
  const assignResult1 = await assignUserToDatabase(token1, 10);
  if (assignResult1) {
    console.log('Test passed: User1 successfully assigned to database 10.');
  } else {
    console.error('Test failed: User1 could not be assigned to database 10.');
  }

  // Test assigning to the same database with a different user (should fail)
  const assignResult2 = await assignUserToDatabase(token2, 10);
  if (!assignResult2) {
    console.log('Test passed: User2 correctly denied assignment to database 10.');
  } else {
    console.error('Test failed: User2 was incorrectly assigned to database 10.');
  }

  // Test assigning User2 to a different database
  const assignResult3 = await assignUserToDatabase(token2, 11);
  if (assignResult3) {
    console.log('Test passed: User2 successfully assigned to database 11.');
  } else {
    console.error('Test failed: User2 could not be assigned to database 11.');
  }

  // Verify database assignments
  const user1Databases = await axios.get(`${BASE_URL}/storage/databases`, {
    headers: { Authorization: `Bearer ${token1}` }
  });
  console.log('User1 databases:', user1Databases.data);

  const user2Databases = await axios.get(`${BASE_URL}/storage/databases`, {
    headers: { Authorization: `Bearer ${token2}` }
  });
  console.log('User2 databases:', user2Databases.data);

  if (user1Databases.data.includes(10) && !user1Databases.data.includes(11) &&
      user2Databases.data.includes(11) && !user2Databases.data.includes(10)) {
    console.log('Test passed: Database assignments are correct for both users.');
  } else {
    console.error('Test failed: Database assignments are incorrect.');
  }
}

async function runTests() {
  try {
    token1 = await createUserAndLogin(user1.username, user1.password);
    token2 = await createUserAndLogin(user2.username, user2.password);

    await testDatabasePermissions();
    console.log('All permission tests completed.');
  } catch (error) {
    console.error('An error occurred during testing:', error.message);
  }
}

runTests();
</FILE>
<FILE path="/home/travis/Projects/database/test/check-db-permission-delete.test.ts">
import axios from 'axios';

const BASE_URL = 'http://localhost:6969';
const user1 = { username: 'testuser1_del_perm', password: 'testpassword1' };
const user2 = { username: 'testuser2_del_perm', password: 'testpassword2' };
let token1: string;
let token2: string;

async function createUserAndLogin(username: string, password: string): Promise<string> {
  console.log(`Creating user or logging in for ${username}...`);
  try {
    await axios.post(`${BASE_URL}/storage/user`, { username, password });
    console.log(`User ${username} created successfully.`);
  } catch (error) {
    console.log(`User ${username} already exists, proceeding to login.`);
  }

  const loginResponse = await axios.post(`${BASE_URL}/storage/login`, { username, password });
  return loginResponse.data.access_token;
}

async function assignUserToDatabase(token: string, dbIndex: number): Promise<boolean> {
  try {
    await axios.post(`${BASE_URL}/storage/assign-db`, { dbIndex }, {
      headers: { Authorization: `Bearer ${token}` }
    });
    console.log(`User assigned to database ${dbIndex} successfully.`);
    return true;
  } catch (error) {
    console.log(`Failed to assign user to database ${dbIndex}: ${error.response?.data}`);
    return false;
  }
}

async function deleteDatabase(token: string, dbIndex: number): Promise<boolean> {
  try {
    await axios.delete(`${BASE_URL}/storage/database/${dbIndex}`, {
      headers: { Authorization: `Bearer ${token}` }
    });
    console.log(`Database ${dbIndex} deleted successfully.`);
    return true;
  } catch (error) {
    console.log(`Failed to delete database ${dbIndex}: ${error.response?.data}`);
    return false;
  }
}

async function testDatabaseDeletionPermissions() {
  console.log('Testing database deletion permissions...');

  // Assign User1 to database 20
  await assignUserToDatabase(token1, 20);

  // Assign User2 to database 21
  await assignUserToDatabase(token2, 21);

  // Test User2 trying to delete User1's database (should fail)
  const deleteResult2 = await deleteDatabase(token2, 20);
  if (!deleteResult2) {
    console.log('Test passed: User2 correctly denied deletion of User1\'s database (20).');
  } else {
    console.error('Test failed: User2 incorrectly allowed to delete User1\'s database (20).');
  }

  // Test User1 trying to delete User2's database (should fail)
  const deleteResult4 = await deleteDatabase(token1, 21);
  if (!deleteResult4) {
    console.log('Test passed: User1 correctly denied deletion of User2\'s database (21).');
  } else {
    console.error('Test failed: User1 incorrectly allowed to delete User2\'s database (21).');
  }

  // Verify database assignments after attempted deletions
  const user1DatabasesA = await axios.get(`${BASE_URL}/storage/databases`, {
    headers: { Authorization: `Bearer ${token1}` }
  });
  console.log('User1 databases after attempted deletions:', user1DatabasesA.data);

  const user2DatabasesA = await axios.get(`${BASE_URL}/storage/databases`, {
    headers: { Authorization: `Bearer ${token2}` }
  });
  console.log('User2 databases after attempted deletions:', user2DatabasesA.data);

  // Test User1 deleting their own database (should succeed)
  const deleteResult1 = await deleteDatabase(token1, 20);
  if (deleteResult1) {
    console.log('Test passed: User1 successfully deleted their own database (20).');
  } else {
    console.error('Test failed: User1 could not delete their own database (20).');
  }
  
  // Test User2 deleting their own database (should succeed)
  const deleteResult3 = await deleteDatabase(token2, 21);
  if (deleteResult3) {
    console.log('Test passed: User2 successfully deleted their own database (21).');
  } else {
    console.error('Test failed: User2 could not delete their own database (21).');
  }

  // Verify database assignments after deletions
  const user1Databases = await axios.get(`${BASE_URL}/storage/databases`, {
    headers: { Authorization: `Bearer ${token1}` }
  });
  console.log('User1 databases after deletions:', user1Databases.data);

  const user2Databases = await axios.get(`${BASE_URL}/storage/databases`, {
    headers: { Authorization: `Bearer ${token2}` }
  });
  console.log('User2 databases after deletions:', user2Databases.data);

  if (!user1Databases.data.includes(20) && !user2Databases.data.includes(21)) {
    console.log('Test passed: Database assignments are correct after deletions.');
  } else {
    console.error('Test failed: Database assignments are incorrect after deletions.');
  }

  if (user1DatabasesA.data.includes(20) && user2DatabasesA.data.includes(21)) {
    console.log('Test passed: Database assignments are correct after attempted deletions.');
  } else {
    console.error('Test failed: Database assignments are incorrect after deletions.');
  }
}

async function runTests() {
  try {
    token1 = await createUserAndLogin(user1.username, user1.password);
    token2 = await createUserAndLogin(user2.username, user2.password);

    await testDatabaseDeletionPermissions();
    console.log('All database deletion permission tests completed.');
  } catch (error) {
    console.error('An error occurred during testing:', error.message);
  }
}

runTests();
</FILE>
<FILE path="/home/travis/Projects/database/test/delete-database.test.ts">
import axios from 'axios';

const BASE_URL = 'http://localhost:6969';
const username = 'testuser_delete_db';
const password = 'testpassword';
let token: string;

async function createUserAndLogin() {
  console.log('Creating user or logging in...');
  try {
    await axios.post(`${BASE_URL}/storage/user`, { username, password });
    console.log('User created successfully.');
  } catch (error) {
    console.log('User already exists, proceeding to login.');
  }

  const loginResponse = await axios.post(`${BASE_URL}/storage/login`, { username, password });
  token = loginResponse.data.access_token;
}

async function assignUserToDatabase(dbIndex: number) {
  console.log(`Assigning user to database ${dbIndex}...`);
  await axios.post(`${BASE_URL}/storage/assign-db`, { dbIndex }, {
    headers: { Authorization: `Bearer ${token}` }
  });
}

async function testDeleteDatabase() {
  console.log('Testing delete database operation...');

  // Assign user to database 3
  await assignUserToDatabase(3);

  // Set a key in the database
  const setResponse = await axios.post(`${BASE_URL}/storage/set/3/testkey`, { value: 'testvalue' }, {
    headers: { Authorization: `Bearer ${token}` }
  });
  console.log('Set response status:', setResponse.status);
  console.log('Set response text:', setResponse.data);

  // Get the key to verify it's set
  const getResponse = await axios.get(`${BASE_URL}/storage/get/3/testkey`, {
    headers: { Authorization: `Bearer ${token}` }
  });
  console.log('Get response status:', getResponse.status);
  console.log('Get response text:', getResponse.data);

  // Delete the database
  const deleteResponse = await axios.delete(`${BASE_URL}/storage/database/3`, {
    headers: { Authorization: `Bearer ${token}` }
  });
  console.log('Delete database response status:', deleteResponse.status);
  console.log('Delete database response text:', deleteResponse.data);

  // Try to get the key again, should fail or return null
  try {
    const getAfterDeleteResponse = await axios.get(`${BASE_URL}/storage/get/3/testkey`, {
      headers: { Authorization: `Bearer ${token}` }
    });
    console.log('Get after delete response status:', getAfterDeleteResponse.status);
    console.log('Get after delete response text:', getAfterDeleteResponse.data);
  } catch (error) {
    console.log('Get after delete failed as expected:', error.response.status);
  }

  // List databases to verify the deleted database is not present
  const listDatabasesResponse = await axios.get(`${BASE_URL}/storage/databases`, {
    headers: { Authorization: `Bearer ${token}` }
  });
  console.log('List databases response status:', listDatabasesResponse.status);
  console.log('List databases response text:', listDatabasesResponse.data);
}

async function runTests() {
  try {
    await createUserAndLogin();
    await testDeleteDatabase();
    console.log('All delete database tests completed successfully.');
  } catch (error) {
    console.error('An error occurred during testing:', error.message);
  }
}

runTests();
</FILE>
<FILE path="/home/travis/Projects/database/test/info-database.test.ts">
import axios from 'axios';

const BASE_URL = 'http://localhost:6969';
const username = 'testuser_db_info';
const password = 'testpassword';
let token: string;

async function createUserAndLogin() {
  console.log('Creating user or logging in...');
  try {
    await axios.post(`${BASE_URL}/storage/user`, { username, password });
    console.log('User created successfully.');
  } catch (error) {
    console.log('User already exists, proceeding to login.');
  }

  const loginResponse = await axios.post(`${BASE_URL}/storage/login`, { username, password });
  token = loginResponse.data.access_token;
}

async function assignUserToDatabase(dbIndex: number) {
  console.log(`Assigning user to database ${dbIndex}...`);
  await axios.post(`${BASE_URL}/storage/assign-db`, { dbIndex }, {
    headers: { Authorization: `Bearer ${token}` }
  });
}

async function testDatabaseInfo() {
  console.log('Testing database info operation...');

  // Assign user to database 5
  await assignUserToDatabase(5);

  // Set some data in the database
  await axios.post(`${BASE_URL}/storage/set/5/testkey1`, { value: 'testvalue1' }, {
    headers: { Authorization: `Bearer ${token}` }
  });
  await axios.post(`${BASE_URL}/storage/set/5/testkey2`, { value: 'testvalue2' }, {
    headers: { Authorization: `Bearer ${token}` }
  });

  // Get database info
  const dbInfoResponse = await axios.get(`${BASE_URL}/storage/database/5/info`, {
    headers: { Authorization: `Bearer ${token}` }
  });
  console.log('Database info response status:', dbInfoResponse.status);
  console.log('Database info response data:', dbInfoResponse.data);

  // Verify database info
  if (dbInfoResponse.data.keyCount === 2) {
    console.log('Database info test passed: Key count matches.');
  } else {
    console.error('Database info test failed: Key count does not match.');
  }

  if (typeof dbInfoResponse.data.sizeInBytes === 'number' && dbInfoResponse.data.sizeInBytes > 0) {
    console.log('Database info test passed: Size in bytes is a positive number.');
  } else {
    console.error('Database info test failed: Size in bytes is not a positive number.');
  }
}

async function runTests() {
  try {
    await createUserAndLogin();
    await testDatabaseInfo();
    console.log('All database info tests completed successfully.');
  } catch (error) {
    console.error('An error occurred during testing:', error.message);
  }
}

runTests();
</FILE>
<FILE path="/home/travis/Projects/database/test/list-database.test.ts">
import axios from 'axios';

const BASE_URL = 'http://localhost:6969';
const username = 'testuser_list_db';
const password = 'testpassword';
let token: string;

async function createUserAndLogin() {
  console.log('Creating user or logging in...');
  try {
    await axios.post(`${BASE_URL}/storage/user`, { username, password });
    console.log('User created successfully.');
  } catch (error) {
    console.log('User already exists, proceeding to login.');
  }

  const loginResponse = await axios.post(`${BASE_URL}/storage/login`, { username, password });
  token = loginResponse.data.access_token;
}

async function assignUserToDatabase(dbIndex: number) {
  console.log(`Assigning user to database ${dbIndex}...`);
  await axios.post(`${BASE_URL}/storage/assign-db`, { dbIndex }, {
    headers: { Authorization: `Bearer ${token}` }
  });
}

async function testListDatabases() {
  console.log('Testing list databases operation...');

  // Assign user to multiple databases
  await assignUserToDatabase(1);
  await assignUserToDatabase(2);
  await assignUserToDatabase(3);

  // List databases
  const listDatabasesResponse = await axios.get(`${BASE_URL}/storage/databases`, {
    headers: { Authorization: `Bearer ${token}` }
  });
  console.log('List databases response status:', listDatabasesResponse.status);
  console.log('List databases response data:', listDatabasesResponse.data);

  // Verify the response
  const databases = listDatabasesResponse.data;
  if (databases.includes(1) && databases.includes(2) && databases.includes(3)) {
    console.log('List databases test passed: All assigned databases are present.');
  } else {
    console.error('List databases test failed: Not all assigned databases are present.');
  }

  // Test database info
  console.log('Testing get database info...');
  const dbInfoResponse = await axios.get(`${BASE_URL}/storage/database/1/info`, {
    headers: { Authorization: `Bearer ${token}` }
  });
  console.log('Database info response status:', dbInfoResponse.status);
  console.log('Database info response data:', dbInfoResponse.data);

  // Test user info
  console.log('Testing get user info...');
  const userInfoResponse = await axios.get(`${BASE_URL}/storage/user/info`, {
    headers: { Authorization: `Bearer ${token}` }
  });
  console.log('User info response status:', userInfoResponse.status);
  console.log('User info response data:', userInfoResponse.data);
}

async function runTests() {
  try {
    await createUserAndLogin();
    await testListDatabases();
    console.log('All list database tests completed successfully.');
  } catch (error) {
    console.error('An error occurred during testing:', error.message);
  }
}

runTests();
</FILE>
<FILE path="/home/travis/Projects/database/test:check-db-permission-create.stdout.txt">
Creating user or logging in for testuser1_perm...
User testuser1_perm already exists, proceeding to login.
Creating user or logging in for testuser2_perm...
User testuser2_perm already exists, proceeding to login.
Testing database permissions...
User assigned to database 10 successfully.
Test passed: User1 successfully assigned to database 10.
Failed to assign user to database 10: [object Object]
Test passed: User2 correctly denied assignment to database 10.
User assigned to database 11 successfully.
Test passed: User2 successfully assigned to database 11.
User1 databases: [ 10 ]
User2 databases: [ 11 ]
Test passed: Database assignments are correct for both users.
All permission tests completed.

</FILE>
<FILE path="/home/travis/Projects/database/test:check-db-permission-delete.stdout.txt">
Creating user or logging in for testuser1_del_perm...
User testuser1_del_perm already exists, proceeding to login.
Creating user or logging in for testuser2_del_perm...
User testuser2_del_perm already exists, proceeding to login.
Testing database deletion permissions...
User assigned to database 20 successfully.
User assigned to database 21 successfully.
Failed to delete database 20: [object Object]
Test passed: User2 correctly denied deletion of User1's database (20).
Failed to delete database 21: [object Object]
Test passed: User1 correctly denied deletion of User2's database (21).
User1 databases after attempted deletions: [ 20 ]
User2 databases after attempted deletions: [ 21 ]
Database 20 deleted successfully.
Test passed: User1 successfully deleted their own database (20).
Database 21 deleted successfully.
Test passed: User2 successfully deleted their own database (21).
User1 databases after deletions: []
User2 databases after deletions: []
Test passed: Database assignments are correct after deletions.
Test passed: Database assignments are correct after attempted deletions.
All database deletion permission tests completed.

</FILE>
<FILE path="/home/travis/Projects/database/test:delete-database.stdout.txt">
Creating user or logging in...
User created successfully.
Testing delete database operation...
Assigning user to database 3...
Set response status: 201
Set response text: OK
Get response status: 200
Get response text: testvalue
Delete database response status: 200
Delete database response text: Database deleted successfully
Get after delete failed as expected: 401
List databases response status: 200
List databases response text: []
All delete database tests completed successfully.

</FILE>
<FILE path="/home/travis/Projects/database/test:info-database.stdout.txt">
Creating user or logging in...
User already exists, proceeding to login.
Testing database info operation...
Assigning user to database 5...
Database info response status: 200
Database info response data: { keyCount: 2, sizeInBytes: 57 }
Database info test passed: Key count matches.
Database info test passed: Size in bytes is a positive number.
All database info tests completed successfully.

</FILE>
<FILE path="test/check-record-permission-crud.test.ts" TARGET>
(empty file)
</FILE>
<REQUEST>
should function like the other tests
</REQUEST>