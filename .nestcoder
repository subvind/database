# NESTCODER

You are NestCoder, a HTMX, EJS and TypeScript/NestJS language coding assistant.

## INPUT: 

You will receive a TARGET <FILE/> in the EJS or TypeScript/NestJS language, some additional <FILE/>'s for context, and a change or refactor <REQUEST/>, from the user.

## OUTPUT:

You must answer with one or more <FILE/> tags, including files to be overwritten, in order to fulfill the user's request.

---

# EXAMPLE NESTCODER USAGE

## Suppose you're given the following INPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/_.ts">
// A polymorphic List with two constructors:
// - Cons: appends an element to a list
// - Nil: the empty list
export type List<A>
  = { "$": "Cons", head: A, tail: List<A> }
  | { "$": "Nil" };
</FILE>

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts" TARGET>
// The map function for List, to be implemented
import { List } from "./_";

export function map<A, B>(fn: (a: A) => B, list: List<A>): List<B> {
  ?
}
</FILE>

<REQUEST>
complete the map function
</REQUEST>

## Then, you must answer with the following OUTPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts">
import { List } from "./_";

// Applies a function to each element of a list.
// - fn: the function to be applied
// - xs: the elements to apply fn to
// = a new list with fn applied to all elements
export function map<A, B>(xs: List<A>, fn: (a: A) => B): List<B> {
  switch (xs.$) {
    case "Cons": {
      var head = fn(xs.head);
      var tail = map(xs.tail, fn);
      return { $: "Cons", head, tail };
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
</FILE>

(Because it fulfills the user's request perfectly.)

---

# GUIDE FOR THE TYPESCRIPT LANGUAGE

- Your code must be inspired by pure functional programming languages like Haskell.

- Every file must declare only, and only one, top-level function or datatype.

- Functions must be pure, using switch instead of 'if-else' or 'case-of'.

- When defining local variables, align equal signs whenever possible.

- Use CamelCase for everything. (IMPORTANT)

- A 'Foo/Bar' top-level definition must be either on './Foo/Bar.ts' or './Foo/Bar/_.ts'. 

# GUIDE FOR THE EJS LANGUAGE

- Use HTMX for frontend.

## Top-Level Function

Every .ts file must define ONE top-level function. Example:

```typescript
// Calculates the size of an HTerm
// - term: the HTerm to measure
// = the number of nodes in the term
export function size(term: HTerm): number {
  switch (term.$) {
    case "Lam": {
      var bod_size = size(term.bod({$: "Var", nam: term.nam}));
      return 1 + bod_size;
    }
    case "App": {
      var fun_size = size(term.fun);
      var arg_size = size(term.arg);
      return 1 + fun_size + arg_size;
    }
    case "Var": {
      return 1;
    }
  }
}
```

Where:
- The function name is defined (e.g., 'size')
- Parameters are specified with their types (e.g., 'term: HTerm')
- The return type is specified (e.g., ': number')
- The function body uses a switch statement for pattern matching
- Local variables are used to make the code less horizontal

## Top-Level Datatype

Alternatively, a .ts file can also define a datatype (ADT). Example:

```typescript
// Represents a Higher-Order Abstract Syntax Term
// - Lam: lambda abstraction
// - App: function application
// - Var: variable
export type HTerm
  = { $: "Lam", bod: (x: HTerm) => HTerm }
  | { $: "App", fun: HTerm, arg: HTerm }
  | { $: "Var", nam: string }
```

ADTs must follow this convention:
- Constructors represented as objects
- The dollar-sign is used for the constructor name
- Other object fields are the constructor fields

## Idiomatic TypeScript Examples

Below are some additional idiomatic TypeScript in the purely functional style: 

### List/zip.ts

```typescript
import { List } from "./_";

// Combines two lists into a list of pairs
// - xs: the first input list
// - ys: the second input list
// = a new list of pairs, with length equal to the shorter input list
export function zip<A, B>(xs: List<A>, ys: List<B>): List<[A, B]> {
  switch (xs.$) {
    case "Cons": {
      switch (ys.$) {
        case "Cons": {
          var head = [xs.head, ys.head] as [A,B];
          var tail = zip(xs.tail, ys.tail);
          return { $: "Cons", head, tail };
        }
        case "Nil": {
          return { $: "Nil" };
        }
      }
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### List/filter.ts

```typescript
import { List } from "./_";

// Filters a list based on a predicate function
// - xs: the input list
// - pred: the predicate function to test each element
// = a new list containing only elements that satisfy the predicate
export function filter<A>(xs: List<A>, pred: (a: A) => boolean): List<A> {
  switch (xs.$) {
    case "Cons": {
      var head = xs.head;
      var tail = filter(xs.tail, pred);
      return pred(xs.head) ? { $: "Cons", head, tail } : tail;
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### Tree/_.ts

```typescript
// Represents a binary tree
// - Node: an internal node with a value and two subtrees
// - Leaf: a leaf node (empty)
export type Tree<A>
  = { $: "Node", val: A, left: Tree<A>, right: Tree<A> }
  | { $: "Leaf" };
```

### Tree/sum.ts

```typescript
import { Tree } from "./_";

// Sums all values in a numeric tree
// - tree: the tree to sum
// = the sum of all values in the tree
export function sum(tree: Tree<number>): number {
  switch (tree.$) {
    case "Node": {
      var left  = sum(tree.left);
      var right = sum(tree.right);
      return tree.val + left + right;
    }
    case "Leaf": {
      return 0;
    }
  }
}
```

### V3/_.ts

```typescript
// Represents a 3D vector
export type V3
  = { $: "V3", x: number, y: number, z: number };
```

### V3/dot.ts

```typescript
import { V3 } from "./_";

// Calculates the dot product of two 3D vectors
// - a: the first vector
// - b: the second vector
// = the dot product of a and b
export function dot(a: V3, b: V3): number {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}
```

---

# NOTES

- Make ONLY the changes necessary to correctly fulfill the user's REQUEST.

- Do NOT fix, remove, complete or alter any parts unrelated to the REQUEST.

- Pay attention to the user's style, and mimic it as close as possible.

- Pay attention to the TypeScript examples and mimic their style as a default.

- Consult TypeScript guide to emit idiomatic correct code.

- Do NOT use or assume the existence of files that weren't shown to you.

- Be precise and careful in your modifications.

---

# TASK

You will now be given the actual INPUT you must work with.

<FILE path="/home/travis/Projects/database/src/app.module.ts">
import { Module } from '@nestjs/common';
import { AuthModule } from './auth/auth.module';
import { StorageModule } from './storage/storage.module';
import { ScheduleModule } from '@nestjs/schedule';

@Module({
  imports: [
    StorageModule,
    AuthModule,
    ScheduleModule.forRoot(),
  ],
})
export class AppModule {}
</FILE>
<FILE path="/home/travis/Projects/database/src/storage/storage.module.ts">
import { Module } from '@nestjs/common';
import { StorageService } from './storage.service';
import { StorageController } from './storage.controller';
import { JwtModule } from '@nestjs/jwt';
import { ScheduleModule } from '@nestjs/schedule';

@Module({
  imports: [
    JwtModule.register({
      secret: 'your_jwt_secret', // TODO: In production, use an environment variable
      signOptions: { expiresIn: '60m' },
    }),
    ScheduleModule.forRoot(),
  ],
  providers: [StorageService],
  controllers: [StorageController],
  exports: [StorageService],
})
export class StorageModule {}
</FILE>
<FILE path="/home/travis/Projects/database/src/storage/storage.service.ts">
import { Injectable, OnModuleInit, OnModuleDestroy, UnauthorizedException, ForbiddenException } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import * as fs from 'fs/promises';
import * as bcrypt from 'bcrypt';
import { JwtService } from '@nestjs/jwt';

interface User {
  username: string;
  passwordHash: string;
  databases: number[];
  isAdmin: boolean;
}

@Injectable()
export class StorageService implements OnModuleInit, OnModuleDestroy {
  private databases: Map<number, Map<string, any>> = new Map();
  private users: Map<string, User> = new Map();
  private walFile: string = 'data/wal.log';
  private snapshotFile: string = 'data/snapshot.json';
  private usersFile: string = 'data/users.json';
  private walStream: fs.FileHandle | null = null;

  constructor(private jwtService: JwtService) {}

  async onModuleInit() {
    await this.loadSnapshot();
    await this.loadUsers();
    await this.replayWAL();
    this.walStream = await fs.open(this.walFile, 'a');
  }

  async onModuleDestroy() {
    await this.createSnapshot();
    await this.saveUsers();
    await this.walStream?.close();
  }

  private async loadSnapshot() {
    try {
      const data = await fs.readFile(this.snapshotFile, 'utf-8');
      const parsedData = JSON.parse(data);
      this.databases = new Map(Object.entries(parsedData).map(([key, value]) => [Number(key), new Map(Object.entries(value))]));
    } catch (error) {
      console.log('No snapshot found or error loading snapshot');
    }
  }

  private async loadUsers() {
    try {
      const data = await fs.readFile(this.usersFile, 'utf-8');
      const parsedData = JSON.parse(data);
      this.users = new Map(Object.entries(parsedData));
    } catch (error) {
      console.log('No users file found or error loading users');
    }
  }

  private async replayWAL() {
    try {
      const data = await fs.readFile(this.walFile, 'utf-8');
      const lines = data.split('\n').filter(line => line.trim() !== '');
      for (const line of lines) {
        const [operation, ...args] = JSON.parse(line);
        switch (operation) {
          case 'set':
            this.set(args[0], Number(args[1]), args[2], args[3]);
            break;
          case 'incr':
            this.incr(args[0], Number(args[1]), args[2]);
            break;
          case 'sadd':
            this.sadd(args[0], Number(args[1]), args[2], ...args.slice(3));
            break;
          case 'del':
            this.del(args[0], Number(args[1]), ...args.slice(2));
            break;
          case 'expire':
            this.expire(args[0], Number(args[1]), args[2], Number(args[3]));
            break;
          case 'rpush':
            this.rpush(args[0], Number(args[1]), args[2], ...args.slice(3));
            break;
          case 'lpop':
            this.lpop(args[0], Number(args[1]), args[2]);
            break;
        }
      }
    } catch (error) {
      console.log('No WAL found or error replaying WAL');
    }
  }

  private async appendToWAL(operation: string, ...args: any[]) {
    const logEntry = JSON.stringify([operation, ...args]) + '\n';
    await this.walStream?.write(logEntry);
  }

  private async createSnapshot() {
    const snapshotData = JSON.stringify(Object.fromEntries(Array.from(this.databases.entries()).map(([key, value]) => [key, Object.fromEntries(value)])));
    await fs.writeFile(this.snapshotFile, snapshotData);
    await fs.truncate(this.walFile, 0);
  }

  private async saveUsers() {
    const userData = JSON.stringify(Object.fromEntries(this.users));
    await fs.writeFile(this.usersFile, userData);
  }

  async createUser(username: string, password: string): Promise<void> {
    if (this.users.has(username)) {
      throw new Error('User already exists');
    }
    const saltRounds = 10;
    const passwordHash = await bcrypt.hash(password, saltRounds);
    let isAdmin: boolean = false;
    if (process.env.ADMIN) {
      if (process.env.ADMIN === username) {
        isAdmin = true;
      }
    } else {
      if (username === 'root') {
        isAdmin = true
      }
    }
    const newUser: User = {
      username,
      passwordHash,
      databases: [],
      isAdmin
    };
    this.users.set(username, newUser);
    await this.saveUsers();
  }

  async validateUser(username: string, password: string): Promise<any> {
    const user = this.users.get(username);
    if (user && await bcrypt.compare(password, user.passwordHash)) {
      const { passwordHash, ...result } = user;
      return result;
    }
    return null;
  }

  async login(user: any) {
    const payload = { username: user.username, sub: user.userId };
    return {
      access_token: this.jwtService.sign(payload),
    };
  }

  async assignUserToDatabase(username: string, dbIndex: number): Promise<void> {
    const user = this.users.get(username);
    if (!user) throw new Error('User not found');
    if (!user.databases.includes(dbIndex)) {
      user.databases.push(dbIndex);
      await this.saveUsers();
    }
  }

  private getDatabase(dbIndex: number): Map<string, string[]> {
    if (!this.databases.has(dbIndex)) {
      this.databases.set(dbIndex, new Map());
    }
    return this.databases.get(dbIndex)!;
  }

  private checkUserAccess(username: string, dbIndex: number): boolean {
    const user = this.users.get(username);
    return user ? user.databases.includes(dbIndex) : false;
  }

  async rpush(username: string, dbIndex: number, key: string, ...values: string[]): Promise<number> {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    if (!db.has(key)) {
      db.set(key, []);
    }
    const list = db.get(key)!;
    list.push(...values);
    await this.appendToWAL('rpush', username, dbIndex, key, ...values);
    return list.length;
  }

  lrange(username: string, dbIndex: number, key: string, start: number, stop: number): string[] {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    const list = db.get(key) || [];
    if (start < 0) start = Math.max(list.length + start, 0);
    if (stop < 0) stop = Math.max(list.length + stop, 0);
    stop = Math.min(stop, list.length - 1);
    return list.slice(start, stop + 1);
  }

  async lpop(username: string, dbIndex: number, key: string): Promise<string | null> {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    const list = db.get(key);
    if (!list || list.length === 0) {
      return null;
    }
    const item = list.shift()!;
    await this.appendToWAL('lpop', username, dbIndex, key);
    return item;
  }

  llen(username: string, dbIndex: number, key: string): number {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    return db.get(key)?.length || 0;
  }

  // String Operations
  async set(username: string, dbIndex: number, key: string, value: string): Promise<'OK'> {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    db.set(key, [value]); // Store value as an array
    await this.appendToWAL('set', username, dbIndex, key, value);
    return 'OK';
  }

  get(username: string, dbIndex: number, key: string): string | null {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    const value = db.get(key);
    return Array.isArray(value) ? value[0] : null;
  }

  async incr(username: string, dbIndex: number, key: string): Promise<number> {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    let value = db.get(key);
    if (!value) {
      value = ['0'];
    } else if (!Array.isArray(value) || typeof Number(value[0]) !== 'number') {
      throw new Error('Value is not a number');
    }
    let number = Number(value[0]) + 1;
    value[0] = `${number}`;
    db.set(key, value);
    await this.appendToWAL('incr', username, dbIndex, key);
    return number;
  }

  async sadd(username: string, dbIndex: number, key: string, ...members: string[]): Promise<number> {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    let set = db.get(key);
    if (!set || !Array.isArray(set)) {
      set = [];
      db.set(key, set);
    }
    const initialSize = set.length;
    members.forEach(member => {
      if (!set.includes(member)) {
        set.push(member);
      }
    });
    const addedCount = set.length - initialSize;
    await this.appendToWAL('sadd', username, dbIndex, key, ...members);
    return addedCount;
  }

  smembers(username: string, dbIndex: number, key: string): string[] {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    const set = db.get(key);
    return set instanceof Set ? Array.from(set) : [];
  }

  sismember(username: string, dbIndex: number, key: string, member: string): boolean {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    const set = db.get(key);
    return set instanceof Set ? set.has(member) : false;
  }

  // Key Management
  async del(username: string, dbIndex: number, ...keys: string[]): Promise<number> {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    let count = 0;
    for (const key of keys) {
      if (db.delete(key)) {
        count++;
      }
    }
    await this.appendToWAL('del', username, dbIndex, ...keys);
    return count;
  }

  exists(username: string, dbIndex: number, ...keys: string[]): number {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    return keys.filter(key => db.has(key)).length;
  }

  async expire(username: string, dbIndex: number, key: string, seconds: number): Promise<boolean> {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    if (!db.has(key)) {
      return false;
    }
    setTimeout(() => {
      db.delete(key);
    }, seconds * 1000);
    await this.appendToWAL('expire', username, dbIndex, key, seconds);
    return true;
  }

  async triggerSnapshot(): Promise<void> {
    await this.createSnapshot();
    await this.saveUsers();
  }

  @Cron(CronExpression.EVERY_30_SECONDS)
  async generateSnapshot() {
    console.log('Generating snapshot...');
    await this.createSnapshot();
    await this.saveUsers();
    console.log('Snapshot generated successfully.');
  }

  async deleteDatabase(username: string, dbIndex: number): Promise<void> {
    const user = this.users.get(username);
    if (!user) throw new UnauthorizedException('User not found');
    if (!user.databases.includes(dbIndex)) throw new ForbiddenException('User does not have access to this database');

    this.databases.delete(dbIndex);
    user.databases = user.databases.filter(db => db !== dbIndex);
    await this.saveUsers();
    await this.appendToWAL('deleteDatabase', username, dbIndex);
  }

  async getDatabaseInfo(username: string, dbIndex: number): Promise<any> {
    if (!this.checkUserAccess(username, dbIndex)) {
      throw new UnauthorizedException('User does not have access to this database');
    }
    const db = this.getDatabase(dbIndex);
    return {
      keyCount: db.size,
      sizeInBytes: JSON.stringify(Array.from(db)).length,
    };
  }

  async getUserInfo(username: string): Promise<any> {
    const user = this.users.get(username);
    if (!user) throw new UnauthorizedException('User not found');
    const { passwordHash, ...userInfo } = user;
    return userInfo;
  }

  async listDatabases(username: string): Promise<number[]> {
    const user = this.users.get(username);
    if (!user) throw new UnauthorizedException('User not found');
    return user.databases;
  }

  async listUsers(username: string): Promise<string[]> {
    const user = this.users.get(username);
    if (!user || !user.isAdmin) throw new UnauthorizedException('Unauthorized');
    return Array.from(this.users.keys());
  }
}
</FILE>
<FILE path="/home/travis/Projects/database/src/storage/storage.controller.ts">
import { Controller, Post, Get, Body, Param, Query, UseGuards, Request, Delete } from '@nestjs/common';
import { StorageService } from './storage.service';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';
import { LocalAuthGuard } from '../auth/local-auth.guard';

@Controller('storage')
export class StorageController {
  constructor(private readonly storageService: StorageService) {}

  @Post('user')
  async createUser(@Body('username') username: string, @Body('password') password: string): Promise<string> {
    await this.storageService.createUser(username, password);
    return 'User created successfully';
  }

  @UseGuards(LocalAuthGuard)
  @Post('login')
  async login(@Request() req) {
    return this.storageService.login(req.user);
  }

  @UseGuards(JwtAuthGuard)
  @Post('assign-db')
  async assignUserToDatabase(@Request() req, @Body('dbIndex') dbIndex: number): Promise<string> {
    await this.storageService.assignUserToDatabase(req.user.username, dbIndex);
    return 'User assigned to database successfully';
  }

  @UseGuards(JwtAuthGuard)
  @Post('rpush/:dbIndex/:key')
  async rpush(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string,
    @Body('values') values: string[]
  ): Promise<number> {
    return await this.storageService.rpush(req.user.username, Number(dbIndex), key, ...values);
  }

  @UseGuards(JwtAuthGuard)
  @Get('lrange/:dbIndex/:key')
  lrange(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string,
    @Query('start') start: number,
    @Query('stop') stop: number,
  ): string[] {
    return this.storageService.lrange(req.user.username, Number(dbIndex), key, Number(start), Number(stop));
  }

  @UseGuards(JwtAuthGuard)
  @Post('lpop/:dbIndex/:key')
  async lpop(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string
  ): Promise<string | null> {
    return await this.storageService.lpop(req.user.username, Number(dbIndex), key);
  }

  @UseGuards(JwtAuthGuard)
  @Get('llen/:dbIndex/:key')
  llen(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string
  ): number {
    return this.storageService.llen(req.user.username, Number(dbIndex), key);
  }

  @UseGuards(JwtAuthGuard)
  @Post('snapshot')
  async createSnapshot(): Promise<string> {
    await this.storageService.triggerSnapshot();
    return 'Snapshot created successfully';
  }

  @UseGuards(JwtAuthGuard)
  @Post('set/:dbIndex/:key')
  async set(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string,
    @Body('value') value: string
  ): Promise<string> {
    return await this.storageService.set(req.user.username, Number(dbIndex), key, value);
  }

  @UseGuards(JwtAuthGuard)
  @Get('get/:dbIndex/:key')
  get(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string
  ): string | null {
    return this.storageService.get(req.user.username, Number(dbIndex), key);
  }

  @UseGuards(JwtAuthGuard)
  @Post('incr/:dbIndex/:key')
  async incr(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string
  ): Promise<number> {
    return await this.storageService.incr(req.user.username, Number(dbIndex), key);
  }

  @UseGuards(JwtAuthGuard)
  @Post('sadd/:dbIndex/:key')
  async sadd(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string,
    @Body('members') members: string[]
  ): Promise<number> {
    return await this.storageService.sadd(req.user.username, Number(dbIndex), key, ...members);
  }

  @UseGuards(JwtAuthGuard)
  @Get('smembers/:dbIndex/:key')
  smembers(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string
  ): string[] {
    return this.storageService.smembers(req.user.username, Number(dbIndex), key);
  }

  @UseGuards(JwtAuthGuard)
  @Get('sismember/:dbIndex/:key/:member')
  sismember(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string,
    @Param('member') member: string
  ): boolean {
    return this.storageService.sismember(req.user.username, Number(dbIndex), key, member);
  }

  @UseGuards(JwtAuthGuard)
  @Post('del/:dbIndex')
  async del(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Body('keys') keys: string[]
  ): Promise<number> {
    return await this.storageService.del(req.user.username, Number(dbIndex), ...keys);
  }

  @UseGuards(JwtAuthGuard)
  @Get('exists/:dbIndex')
  exists(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Query('keys') keys: string[]
  ): number {
    return this.storageService.exists(req.user.username, Number(dbIndex), ...keys);
  }

  @UseGuards(JwtAuthGuard)
  @Post('expire/:dbIndex/:key')
  async expire(
    @Request() req,
    @Param('dbIndex') dbIndex: number,
    @Param('key') key: string,
    @Body('seconds') seconds: number
  ): Promise<boolean> {
    return await this.storageService.expire(req.user.username, Number(dbIndex), key, seconds);
  }

  @UseGuards(JwtAuthGuard)
  @Delete('database/:dbIndex')
  async deleteDatabase(
    @Request() req,
    @Param('dbIndex') dbIndex: number
  ): Promise<string> {
    await this.storageService.deleteDatabase(req.user.username, Number(dbIndex));
    return 'Database deleted successfully';
  }

  @UseGuards(JwtAuthGuard)
  @Get('database/:dbIndex/info')
  async getDatabaseInfo(
    @Request() req,
    @Param('dbIndex') dbIndex: number
  ): Promise<any> {
    return await this.storageService.getDatabaseInfo(req.user.username, Number(dbIndex));
  }

  @UseGuards(JwtAuthGuard)
  @Get('user/info')
  async getUserInfo(@Request() req): Promise<any> {
    return await this.storageService.getUserInfo(req.user.username);
  }

  @UseGuards(JwtAuthGuard)
  @Get('databases')
  async listDatabases(@Request() req): Promise<number[]> {
    return await this.storageService.listDatabases(req.user.username);
  }

  @UseGuards(JwtAuthGuard)
  @Get('users')
  async listUsers(@Request() req): Promise<string[]> {
    return await this.storageService.listUsers(req.user.username);
  }
}
</FILE>
<FILE path="/home/travis/Projects/database/src/auth/auth.module.ts">
import { Module } from '@nestjs/common';
import { PassportModule } from '@nestjs/passport';
import { JwtStrategy } from './jwt.strategy';
import { LocalStrategy } from './local.strategy';
import { StorageModule } from '../storage/storage.module';

@Module({
  imports: [
    PassportModule,
    StorageModule,
  ],
  providers: [JwtStrategy, LocalStrategy],
})
export class AuthModule {}
</FILE>
<FILE path="/home/travis/Projects/database/src/auth/jwt-auth.guard.ts">
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}

</FILE>
<FILE path="/home/travis/Projects/database/src/auth/local-auth.guard.ts">
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard('local') {}
</FILE>
<FILE path="/home/travis/Projects/database/test/delete-database.test.ts">
import axios from 'axios';

const BASE_URL = 'http://localhost:6969';
const username = 'testuser_delete_db';
const password = 'testpassword';
let token: string;

async function createUserAndLogin() {
  console.log('Creating user or logging in...');
  try {
    await axios.post(`${BASE_URL}/storage/user`, { username, password });
    console.log('User created successfully.');
  } catch (error) {
    console.log('User already exists, proceeding to login.');
  }

  const loginResponse = await axios.post(`${BASE_URL}/storage/login`, { username, password });
  token = loginResponse.data.access_token;
}

async function assignUserToDatabase(dbIndex: number) {
  console.log(`Assigning user to database ${dbIndex}...`);
  await axios.post(`${BASE_URL}/storage/assign-db`, { dbIndex }, {
    headers: { Authorization: `Bearer ${token}` }
  });
}

async function testDeleteDatabase() {
  console.log('Testing delete database operation...');

  // Assign user to database 3
  await assignUserToDatabase(3);

  // Set a key in the database
  const setResponse = await axios.post(`${BASE_URL}/storage/set/3/testkey`, { value: 'testvalue' }, {
    headers: { Authorization: `Bearer ${token}` }
  });
  console.log('Set response status:', setResponse.status);
  console.log('Set response text:', setResponse.data);

  // Get the key to verify it's set
  const getResponse = await axios.get(`${BASE_URL}/storage/get/3/testkey`, {
    headers: { Authorization: `Bearer ${token}` }
  });
  console.log('Get response status:', getResponse.status);
  console.log('Get response text:', getResponse.data);

  // Delete the database
  const deleteResponse = await axios.delete(`${BASE_URL}/storage/database/3`, {
    headers: { Authorization: `Bearer ${token}` }
  });
  console.log('Delete database response status:', deleteResponse.status);
  console.log('Delete database response text:', deleteResponse.data);

  // Try to get the key again, should fail or return null
  try {
    const getAfterDeleteResponse = await axios.get(`${BASE_URL}/storage/get/3/testkey`, {
      headers: { Authorization: `Bearer ${token}` }
    });
    console.log('Get after delete response status:', getAfterDeleteResponse.status);
    console.log('Get after delete response text:', getAfterDeleteResponse.data);
  } catch (error) {
    console.log('Get after delete failed as expected:', error.response.status);
  }

  // List databases to verify the deleted database is not present
  const listDatabasesResponse = await axios.get(`${BASE_URL}/storage/databases`, {
    headers: { Authorization: `Bearer ${token}` }
  });
  console.log('List databases response status:', listDatabasesResponse.status);
  console.log('List databases response text:', listDatabasesResponse.data);
}

async function runTests() {
  try {
    await createUserAndLogin();
    await testDeleteDatabase();
    console.log('All delete database tests completed successfully.');
  } catch (error) {
    console.error('An error occurred during testing:', error.message);
  }
}

runTests();
</FILE>
<FILE path="/home/travis/Projects/database/test/list-database.test.ts">
import axios from 'axios';

const BASE_URL = 'http://localhost:6969';
const username = 'testuser_list_db';
const password = 'testpassword';
let token: string;

async function createUserAndLogin() {
  console.log('Creating user or logging in...');
  try {
    await axios.post(`${BASE_URL}/storage/user`, { username, password });
    console.log('User created successfully.');
  } catch (error) {
    console.log('User already exists, proceeding to login.');
  }

  const loginResponse = await axios.post(`${BASE_URL}/storage/login`, { username, password });
  token = loginResponse.data.access_token;
}

async function assignUserToDatabase(dbIndex: number) {
  console.log(`Assigning user to database ${dbIndex}...`);
  await axios.post(`${BASE_URL}/storage/assign-db`, { dbIndex }, {
    headers: { Authorization: `Bearer ${token}` }
  });
}

async function testListDatabases() {
  console.log('Testing list databases operation...');

  // Assign user to multiple databases
  await assignUserToDatabase(1);
  await assignUserToDatabase(2);
  await assignUserToDatabase(3);

  // List databases
  const listDatabasesResponse = await axios.get(`${BASE_URL}/storage/databases`, {
    headers: { Authorization: `Bearer ${token}` }
  });
  console.log('List databases response status:', listDatabasesResponse.status);
  console.log('List databases response data:', listDatabasesResponse.data);

  // Verify the response
  const databases = listDatabasesResponse.data;
  if (databases.includes(1) && databases.includes(2) && databases.includes(3)) {
    console.log('List databases test passed: All assigned databases are present.');
  } else {
    console.error('List databases test failed: Not all assigned databases are present.');
  }

  // Test database info
  console.log('Testing get database info...');
  const dbInfoResponse = await axios.get(`${BASE_URL}/storage/database/1/info`, {
    headers: { Authorization: `Bearer ${token}` }
  });
  console.log('Database info response status:', dbInfoResponse.status);
  console.log('Database info response data:', dbInfoResponse.data);

  // Test user info
  console.log('Testing get user info...');
  const userInfoResponse = await axios.get(`${BASE_URL}/storage/user/info`, {
    headers: { Authorization: `Bearer ${token}` }
  });
  console.log('User info response status:', userInfoResponse.status);
  console.log('User info response data:', userInfoResponse.data);
}

async function runTests() {
  try {
    await createUserAndLogin();
    await testListDatabases();
    console.log('All list database tests completed successfully.');
  } catch (error) {
    console.error('An error occurred during testing:', error.message);
  }
}

runTests();
</FILE>
<FILE path="/home/travis/Projects/database/test/key-value.test.ts">
import * as request from 'supertest';

const API_URL = 'http://localhost:6969';

async function runTests() {
  let accessToken: string;

  try {
    console.log('Creating user or logging in...');
    try {
      await request(API_URL)
        .post('/storage/user')
        .send({ username: 'testuser', password: 'testpass' });
      console.log('User created successfully.');
    } catch (error) {
      console.log('User already exists, proceeding with login.');
    }

    const loginResponse = await request(API_URL)
      .post('/storage/login')
      .send({ username: 'testuser', password: 'testpass' });

    accessToken = loginResponse.body.access_token;

    console.log('Assigning user to database 0...');
    await request(API_URL)
      .post('/storage/assign-db')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({ dbIndex: 0 });

    console.log('Testing set and get operations...');
    const setResponse = await request(API_URL)
      .post('/storage/set/0/testkey')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({ value: 'testvalue' });

    console.log('Set response status:', setResponse.status);
    console.log('Set response text:', setResponse.text);

    const getResponse = await request(API_URL)
      .get('/storage/get/0/testkey')
      .set('Authorization', `Bearer ${accessToken}`);

    console.log('Get response status:', getResponse.status);
    console.log('Get response text:', getResponse.text);

    console.log('Testing increment operation: starting from 1...');
    await request(API_URL)
      .post('/storage/set/0/counter')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({ value: '1' });

    const incrResponse = await request(API_URL)
      .post('/storage/incr/0/counter')
      .set('Authorization', `Bearer ${accessToken}`);

    console.log('Increment response status:', incrResponse.status);
    console.log('Increment response text:', incrResponse.text);

    const getIncrResponse = await request(API_URL)
      .get('/storage/get/0/counter')
      .set('Authorization', `Bearer ${accessToken}`);

    console.log('Get incremented value status:', getIncrResponse.status);
    console.log('Get incremented value text:', getIncrResponse.text);

    console.log('Testing delete operation...');
    await request(API_URL)
      .post('/storage/set/0/deletekey')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({ value: 'to be deleted' });

    const deleteResponse = await request(API_URL)
      .post('/storage/del/0')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({ keys: ['deletekey'] });

    console.log('Delete response status:', deleteResponse.status);
    console.log('Delete response text:', deleteResponse.text);

    const getDeletedResponse = await request(API_URL)
      .get('/storage/get/0/deletekey')
      .set('Authorization', `Bearer ${accessToken}`);

    console.log('Get deleted key status:', getDeletedResponse.status);
    console.log('Get deleted key text:', getDeletedResponse.text);

    console.log('Testing exists operation...');
    await request(API_URL)
      .post('/storage/set/0/existkey1')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({ value: 'value1' });

    await request(API_URL)
      .post('/storage/set/0/existkey2')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({ value: 'value2' });

    const existsResponse = await request(API_URL)
      .get('/storage/exists/0?keys=existkey1&keys=existkey2&keys=nonexistentkey')
      .set('Authorization', `Bearer ${accessToken}`);

    console.log('Exists response status:', existsResponse.status);
    console.log('Exists response text:', existsResponse.text);

    console.log('All tests completed successfully.');
  } catch (error) {
    console.error('Test failed:', error);
  }
}

runTests();
</FILE>
<FILE path="/home/travis/Projects/database/test/info-user.test.ts">
import axios from 'axios';

const BASE_URL = 'http://localhost:6969';
const username = 'testuser_info';
const password = 'testpassword';
let token: string;

async function createUserAndLogin() {
  console.log('Creating user or logging in...');
  try {
    await axios.post(`${BASE_URL}/storage/user`, { username, password });
    console.log('User created successfully.');
  } catch (error) {
    console.log('User already exists, proceeding to login.');
  }

  const loginResponse = await axios.post(`${BASE_URL}/storage/login`, { username, password });
  token = loginResponse.data.access_token;
}

async function assignUserToDatabase(dbIndex: number) {
  console.log(`Assigning user to database ${dbIndex}...`);
  await axios.post(`${BASE_URL}/storage/assign-db`, { dbIndex }, {
    headers: { Authorization: `Bearer ${token}` }
  });
}

async function testUserInfo() {
  console.log('Testing user info operation...');

  // Get user info
  const userInfoResponse = await axios.get(`${BASE_URL}/storage/user/info`, {
    headers: { Authorization: `Bearer ${token}` }
  });
  console.log('User info response status:', userInfoResponse.status);
  console.log('User info response data:', userInfoResponse.data);

  // Verify user info
  if (userInfoResponse.data.username === username) {
    console.log('User info test passed: Username matches.');
  } else {
    console.error('User info test failed: Username does not match.');
  }

  if (Array.isArray(userInfoResponse.data.databases)) {
    console.log('User info test passed: Databases field is an array.');
  } else {
    console.error('User info test failed: Databases field is not an array.');
  }

  if (typeof userInfoResponse.data.isAdmin === 'boolean') {
    console.log('User info test passed: isAdmin field is a boolean.');
  } else {
    console.error('User info test failed: isAdmin field is not a boolean.');
  }
}

async function runTests() {
  try {
    await createUserAndLogin();
    await assignUserToDatabase(1); // Assign to database 1 for testing
    await testUserInfo();
    console.log('All user info tests completed successfully.');
  } catch (error) {
    console.error('An error occurred during testing:', error.message);
  }
}

runTests();
</FILE>
<FILE path="/home/travis/Projects/database/src/logger/custom-logger.ts">
import { ConsoleLogger, Injectable, Inject } from '@nestjs/common';
import * as fs from 'fs';
import * as path from 'path';

@Injectable()
export class CustomLogger extends ConsoleLogger {
  constructor(
    private logId: string,
  ) {
    super(logId);
    this.setLogLevels(['log', 'error', 'warn', 'debug', 'verbose']);
  }

  log(message: string, context?: string) {
    this.printMessage(message, 'log', context);
    // this.emitLogEvent('log', message);
  }

  warn(message: string, context?: string) {
    this.printMessage(message, 'warn', context);
    // this.emitLogEvent('warn', message);
  }

  error(message: string, trace?: string, context?: string) {
    this.printMessage(message, 'error', context);
    // this.emitLogEvent('error', message);
    if (trace) {
      this.printMessage(trace, 'error', context);
    }
  }

  debug(message: string, context?: string) {
    this.printMessage(message, 'debug', context);
  }

  verbose(message: string, context?: string) {
    this.printMessage(message, 'verbose', context);
  }

  private printMessage(message: string, logLevel: string, context?: string) {
    const output = context ? `[${context}] ${message}` : message;
    console.log(`[${this.getNow()}] [${logLevel.toUpperCase()}] [${this.logId}] ${output}`);
  }

  private getNow(): string {
    return new Date().toISOString();
  }

  static write_to_file(message: string) {
    const logFile = path.join(process.cwd(), 'start:dev.stdout.txt');
    fs.appendFile(logFile, message, (err) => {
      if (err) {
        console.error('Failed to write to log file:', err);
      }
    });
  }

  static clearSTDOUT() {
    const logFile = path.join(process.cwd(), 'start:dev.stdout.txt');
    try {
      fs.writeFileSync(logFile, '');
      console.log(`Log file cleared at ${logFile}`);
    } catch (error) {
      console.error('Failed to clear log file:', error);
    }
  }
}
</FILE>
<FILE path="/home/travis/Projects/database/test:info-user.stdout.txt">
Creating user or logging in...
User created successfully.
Assigning user to database 1...
Testing user info operation...
User info response status: 200
User info response data: { username: 'testuser_info', databases: [ 1 ], isAdmin: false }
User info test passed: Username matches.
User info test passed: Databases field is an array.
User info test passed: isAdmin field is a boolean.
All user info tests completed successfully.

</FILE>
<FILE path="/home/travis/Projects/database/test:list-database.stdout.txt">
Creating user or logging in...
User created successfully.
Testing list databases operation...
Assigning user to database 1...
Assigning user to database 2...
Assigning user to database 3...
List databases response status: 200
List databases response data: [ 1, 2, 3 ]
List databases test passed: All assigned databases are present.
Testing get database info...
Database info response status: 200
Database info response data: { keyCount: 1, sizeInBytes: 35 }
Testing get user info...
User info response status: 200
User info response data: {
  username: 'testuser_list_db',
  databases: [ 1, 2, 3 ],
  isAdmin: false
}
All list database tests completed successfully.

</FILE>
<FILE path="/home/travis/Projects/database/test:delete-database.stdout.txt">
Creating user or logging in...
User already exists, proceeding to login.
Testing delete database operation...
Assigning user to database 3...
Set response status: 201
Set response text: OK
Get response status: 200
Get response text: testvalue
Delete database response status: 200
Delete database response text: Database deleted successfully
Get after delete failed as expected: 401
List databases response status: 200
List databases response text: []
All delete database tests completed successfully.

</FILE>
<FILE path="test/info-database.test.ts" TARGET>
(empty file)
</FILE>
<REQUEST>
should function like the other tests
</REQUEST>